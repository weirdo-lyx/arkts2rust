# STEP 4：扩展表达式解析（优先级 / Pratt Parser）并同步 CodeGen

本 Step 的目标：在不引入 if/while/function 等复杂语法的前提下，扩展表达式解析能力，让项目能够处理更接近真实代码的表达式，并把这些表达式正确生成到 Rust 源码中。

---

## 1. Step4 新增支持的语法点

在 Step2 的基础上新增：
- 一元运算：`!`、`-`（示例：`!a`、`-1`）
- 二元运算：
  - 算术：`+ - * / %`
  - 比较：`< <= > >=`
  - 相等：`== !=`
  - 逻辑：`&& ||`
- 括号：`(expr)`（改变优先级）
- 标识符引用：`x`
- 调用：`ident(expr, expr, ...)`
- 赋值语句：`x = expr;`

硬性禁止（本 Step 不做）：
- `if / while / function`（留到 Step5/6）

---

## 2. AST 扩展（为什么要扩展 AST）

表达式一旦引入优先级，就不能再靠“字符串拼接”或“线性 Token”理解结构了。
例如 `1 + 2 * 3` 的结构是：

```text
   (+)
  /   \
 1    (*)
     /   \
    2     3
```

所以 AST 需要新增节点（见 `src/ast.rs`）：
- `Expr::Ident(String)`：标识符引用
- `Expr::Unary(UnaryExpr)`：一元表达式（`!`、`-`）
- `Expr::Binary(BinaryExpr)`：二元表达式（`+ - * / % == ... && ||`）
- `Expr::Group(Box<Expr>)`：括号表达式（必须保留，否则 CodeGen 会丢括号）
- `Stmt::Assign(AssignStmt)`：赋值语句 `x = expr;`
- `Callee::Ident(String)`：普通函数调用 `f(...)`（同时保留 `Callee::ConsoleLog` 兼容旧步骤）

---

## 3. 表达式优先级与结合性（重点）

我们采用 Pratt Parser（运算符优先级解析）的思路，实现正确的优先级与结合性。

### 3.1 优先级表（从低到高）

| 层级 | 运算符 | 结合性 | 说明 |
|---|---|---|---|
| 1 | `||` | 左结合 | 逻辑或 |
| 2 | `&&` | 左结合 | 逻辑与 |
| 3 | `== !=` | 左结合 | 相等比较 |
| 4 | `< <= > >=` | 左结合 | 大小比较 |
| 5 | `+ -` | 左结合 | 加减 |
| 6 | `* / %` | 左结合 | 乘除模 |
| 7 | 前缀 `! -` | 右结合（前缀） | 一元运算 |
| 8 | 调用 `f(...)` | 左结合（后缀） | 绑定最紧 |
| 9 | primary | - | literal / ident / group |

你可以用几个典型例子检查自己是否理解正确：
- `1 + 2 * 3` 应该解析为 `1 + (2 * 3)`
- `(1 + 2) * 3` 由于括号，应该解析为 `(1 + 2) * 3`
- `a && b || c` 应该解析为 `(a && b) || c`
- `1 < 2 == true` 应该解析为 `(1 < 2) == true`

---

## 4. CodeGen（如何把表达式生成到 Rust）

CodeGen 的核心要求：生成的 Rust 表达式要与 AST 等价。

### 4.1 运算符映射

Step4 的运算符在 Rust 中都有同名语法（`+ - * / % == != < <= > >= && || !`），所以主要工作是：
- 按 AST 结构生成
- **必要时补括号**，避免 Rust 的解析顺序和我们 AST 不一致

### 4.2 括号策略

实现方式（见 `src/codegen.rs`）：
- 给每种表达式定义一个“绑定强度”（bp/优先级）
- 生成子表达式时，如果子表达式优先级低于父表达式，就加括号
- 对左结合运算符，为了保持结合性，右子树使用更高一点的 parent_bp（`bp+1`）来避免 `a-(b-c)` 被打印成 `a-b-c`

---

## 5. 测试（优先级重点 + 错误用例）

本 Step 增加了表达式专用测试（见 `tests/parser_expr_tests.rs`）：
- 覆盖典型优先级用例：`1+2*3`、`(1+2)*3`、`a&&b||c`、`1<2==true` 等
- 覆盖调用与参数表达式：`f(1+2*3, -4)`
- 覆盖赋值语句：`x = expr;`
- 覆盖错误用例（至少 2 个）：缺右括号、操作符后缺表达式

运行：

```bash
cargo test
```

---

## 6. 论文段落（可直接引用/改写）

表达式解析的关键难点在于运算符的优先级与结合性。本文采用 Pratt Parser（运算符优先级解析）实现 ArkTS 子集的表达式语法分析，通过为运算符定义绑定强度并在解析过程中迭代归约，构建出与语义一致的抽象语法树（AST）。在代码生成阶段，本文根据 AST 结构递归生成 Rust 表达式，并结合优先级信息在必要处插入括号，以保证生成代码的求值顺序与源语言一致。通过覆盖典型优先级场景的单元测试与错误用例，验证了解析与生成在最小闭环中的正确性与可维护性。

